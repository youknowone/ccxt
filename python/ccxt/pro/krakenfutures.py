# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.pro.base.exchange import Exchange
import ccxt.async_support
from ccxt.base.errors import BadRequest
from ccxt.base.errors import BadSymbol


class krakenfutures(Exchange, ccxt.async_support.krakenfutures):

    def describe(self):
        return self.deep_extend(super(krakenfutures, self).describe(), {
            'has': {
                'ws': True,
                'watchBalance': False,  # for now
                'watchMyTrades': False,  # for now
                'watchOHLCV': False,  # for now
                'watchOrderBook': False,  # for now
                'watchOrders': False,  # for now
                'watchTicker': True,
                'watchTickers': False,  # for now
                'watchTrades': False,  # for now
                # 'watchHeartbeat': True,
                # 'watchStatus': True,
            },
            'urls': {
                'api': {
                    'ws': {
                        'public': 'wss://futures.kraken.com/ws/v1',
                    },
                },
            },
            # 'versions': {
            #     'ws': '0.2.0',
            # },
            'options': {
                'tradesLimit': 1000,
                'OHLCVLimit': 1000,
                'ordersLimit': 1000,
                'symbolsByOrderId': {},
                'checksum': True,
            },
            'exceptions': {
                'ws': {
                    'exact': {
                        'Event(s) not found': BadRequest,
                    },
                    'broad': {
                        'Currency pair not in ISO 4217-A3 format': BadSymbol,
                    },
                },
            },
        })

    def handle_ticker(self, client, message):
        #
        #   {
        #     "time": 1612270825253,
        #     "feed": "ticker",
        #     "product_id": "PI_XBTUSD",
        #     "bid": 34832.5,
        #     "ask": 34847.5,
        #     "bid_size": 42864,
        #     "ask_size": 2300,
        #     "volume": 262306237,
        #     "dtm": 0,
        #     "leverage": "50x",
        #     "index": 34803.45,
        #     "premium": 0.1,
        #     "last": 34852,
        #     "change": 2.995109121267192,
        #     "funding_rate": 3.891007752e-9,
        #     "funding_rate_prediction": 4.2233756e-9,
        #     "suspended": False,
        #     "tag": "perpetual",
        #     "pair": "XBT:USD",
        #     "openInterest": 107706940,
        #     "markPrice": 34844.25,
        #     "maturityTime": 0,
        #     "relative_funding_rate": 0.000135046879166667,
        #     "relative_funding_rate_prediction": 0.000146960125,
        #     "next_funding_rate_time": 1612281600000,
        #     "volumeQuote": 262306237
        #   }
        #
        product_id = self.safe_string_lower(message, 'product_id')
        name = 'ticker'
        market = self.market(product_id)
        symbol = market['symbol']
        messageHash = name + ':' + symbol
        timestamp = self.milliseconds()
        result = {
            'symbol': symbol,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': None,
            'low': None,
            'bid': self.safe_float(message, 'bid'),
            'bidVolume': self.safe_float(message, 'bid_size'),
            'ask': self.safe_float(message, 'ask'),
            'askVolume': self.safe_float(message, 'ask_size'),
            'vwap': None,
            'open': None,
            'close': None,
            'last': self.safe_float(message, 'last'),
            'previousClose': None,
            'change': None,
            'percentage': None,
            'average': None,
            'baseVolume': self.safe_float(message, 'volume'),
            'quoteVolume': self.safe_float(message, 'volumeQuote'),
            'info': message,
        }
        self.tickers[symbol] = result
        client.resolve(result, messageHash)

    async def watch_public(self, name, symbol, params={}):
        await self.load_markets()
        market = self.market(symbol)
        messageHash = name + ':' + market['symbol']
        url = self.urls['api']['ws']['public']
        subscribe = {
            'event': 'subscribe',
            'feed': name,
            'product_ids': [
                market['id'],
            ],
        }
        request = self.deep_extend(subscribe, params)
        return await self.watch(url, messageHash, request, messageHash)

    async def watch_ticker(self, symbol, params={}):
        """
        watches a price ticker, a statistical calculation with the information calculated over the past 24 hours for a specific market
        :param str symbol: unified symbol of the market to fetch the ticker for
        :param dict params: extra parameters specific to the kraken api endpoint
        :returns dict: a `ticker structure <https://docs.ccxt.com/en/latest/manual.html#ticker-structure>`
        """
        return await self.watch_public('ticker', symbol, params)

    async def watch_heartbeat(self, params={}):
        await self.load_markets()
        event = 'heartbeat'
        url = self.urls['api']['ws']['public']
        return await self.watch(url, event)

    def handle_heartbeat(self, client, message):
        #
        # every second(approx) if no other updates are sent
        #
        #     {"event": "heartbeat"}
        #
        event = self.safe_string(message, 'event')
        client.resolve(message, event)

    async def authenticate(self, params={}):
        url = self.urls['api']['ws']['private']
        client = self.client(url)
        authenticated = 'authenticated'
        subscription = self.safe_value(client.subscriptions, authenticated)
        if subscription is None:
            response = await self.privatePostGetWebSocketsToken(params)
            #
            #     {
            #         "error":[],
            #         "result":{
            #             "token":"xeAQ\/RCChBYNVh53sTv1yZ5H4wIbwDF20PiHtTF+4UI",
            #             "expires":900
            #         }
            #     }
            #
            subscription = self.safe_value(response, 'result')
            client.subscriptions[authenticated] = subscription
        return self.safe_string(subscription, 'token')

    def handle_subscription_status(self, client, message):
        #
        # public
        #
        #   {
        #     "event": "subscribed",
        #     "feed": "ticker",
        #     "product_ids": [
        #       "PI_XBTUSD"
        #     ]
        #   }
        #
        # private
        #
        #   {
        #     "event": "subscribed",
        #     "feed": "open_orders",
        #     "api_key": "CMl2SeSn09Tz+2tWuzPiPUjaXEQRGq6qv5UaexXuQ3SnahDQU/gO3aT+",
        #     "original_challenge": "226aee50-88fc-4618-a42a-34f7709570b2",
        #     "signed_challenge":"RE0DVOc7vS6pzcEjGWd/WJRRBWb54RkyvV+AZQSRl4+rap8Rlk64diR+Z9DQILm7qxncswMmJyvP/2vgzqqh+g=="
        #   }
        #
        client.subscriptions[message['feed']] = message

    def handle_error_message(self, client, message):
        #
        #   {
        #     "event": "error",
        #     "message": "Invalid product id"
        #   }
        #
        # TODO: handle error message
        return True

    def handle_message(self, client, message):
        name = message['feed']
        event = self.safe_value(message, 'event')
        if event is not None:
            return self.handle_subscription_status(client, message)
        methods = {
            # public
            'ticker': self.handle_ticker,
        }
        method = self.safe_value(methods, name)
        if method is None:
            return message
        else:
            return method(client, message)
